#include <vector>
#include <algorithm>
#include <numeric>

#ifdef USE_MPRF
	//import
	#include "utils/mpreal.h"
	
	// namespace for math functions
	namespace precision = mpfr;

	//type
	#define PROBA_TYPE precision::mpreal

	// precision setter
	#define SET_PRECISION(precision_) PROBA_TYPE::set_default_prec(precision_);
#else
	// standard type
	#define PROBA_TYPE long double

	// precision setter
	#define SET_PRECISION(precision)

	// namespace for math functions
	namespace precision = std;
#endif

// type definition
typedef class state state_t;
typedef class rule rule_t;
typedef char op_type_t;

// rule interface definition
class rule {
public:
	virtual op_type_t operation(state_t const &s, unsigned int graph_begin, unsigned int graph_end, unsigned short int node_id); /* step (1) */

	virtual unsigned short int numb_childs(state_t const &s, unsigned int gid); /* step (2) */

	virtual std::tuple<size_t /* hash */,
		PROBA_TYPE /* real*/, PROBA_TYPE /* iamg */,
		unsigned short int /* numb_nodes */, unsigned short int /* numb sub-nodes */> 
		child_properties(state_t const &s, unsigned int parent_id, unsigned int child_id); /* step (4) */

	virtual void populate_new_graph(state_t const &s, state_t &new_state, unsigned int gid, unsigned int parent_id, unsigned int child_id); /* step (8) */
};

/*
!!!!!
Iteration protocol is:
  - (1): use a rule to put all operation inside of the vector "operations"

  - (2): calculate the number of subgraphs generated by each graph and populate "num_childs" (*)

  - (3): read the total number of sub_graph generated by each graph and populate "new_gid", "parent_gid" and "parent_sub_id"

  - (4): by iterating on "new_gid" and using the rule, populate "new_hash" and "new_real" and "new_imag" through a simbolic iteration (**),
  	and populate "new_size_b" and "new_size_c" which are respectively the number of node and of sub-nodes for each new graph

  - (5): using "new_hash" sum the probability ("new_real" and "new_imag") of equal graphs, while setting the probability of graph which are equal to 0

  - (6): sort "new_gid" based on probability ("new_real" and "new_imag")

  - (7): reserve all public vector for a new state by iterating over the N first "new_gid" andusing "parent_gid" and "parent_sub_id",
  	and assign "b_begin" and "c_begin".

  - (8): generate all new graphs of the new state by iterating over the N first "new_gid" andusing "parent_gid" and "parent_sub_id".


(*) to compute the number of child you just compute "pow(2, numb_operations)""
(**) it's possible to compute the hash of a child graph without actually computing it for most rules
*/

class state {
public:
	// constructor
	state() {}

	// type definition of a node
	short enum {
		left_t = -3,
		right_t,
		element_t,
	};

	/* vectors can have 3 different sizes :
		- (a) the number of graph (so a single element per graph), and + 1
		- (b) the total number of nodes (sum of the number of nodes for each graph)
		- (c) the total number of nodes (including sub-nodes used to generate node tree)
	*/

	// graph magnitude
	std::vector<PROBA_TYPE> real; /* size (a) */
	std::vector<PROBA_TYPE> imag; /* size (a) */

	// begin for each size
	std::vector<unsigned int> b_begin; /* size (a + 1), refers to vector of size (b) */
	std::vector <unsigned int> c_begin; /* size (a + 1), refers to vectors of size (c) */

	// graph properties
	std::vector<bool> left; /* size (b) */
	std::vector<bool> right; /* size (b) */
	std::vector<short int> nid; /* size (b) */

	// node properties
	std::vector<short int> left_idx__or_element__and_has_most_left_zero_; /* size (c) */
	std::vector<short int> right_idx__or_type_; /* size (c) */
	std::vector<size_t> node_hash; /* size (c) */

private:
	/*
	intermediary vectors used to generate the next state :
	*/

	// vector of operations
	std::vector<op_type_t> operations; /* size (b) */

	// number of sub-graph for each parent
	std::vector<unsigned short int> num_childs; /* size (a) */

	// new graphs
	std::vector<unsigned int> new_gid; /* size (a) for the next iteration */
	std::vector<unsigned int> parent_gid; /* size (a) for the next iteration */
	std::vector<unsigned int> parent_sub_id; /* size (a) for the next iteration */

	// new graph hash
	std::vector<size_t> new_hash; /* size (a) for the next iteration */
	std::vector<unsigned short int> new_size_b; /* size (a) for the next iteration */
	std::vector<unsigned short int> new_size_c; /* size (a) for the next iteration */

	// new graph magnitude
	std::vector<PROBA_TYPE> new_real; /* size (a) for the next iteration */
	std::vector<PROBA_TYPE> new_imag; /* size (a) for the next iteration */

public:
	state_t step(rule_t &rule, unsigned int n_graphs) {
		size_t numb_graphs = real.size();

		/* !!!!!!!!!!!!!!!!
		step (1) 
		 !!!!!!!!!!!!!!!! */

		#pragma omp parallel for
		for (unsigned int gid = 0; gid < numb_graphs; ++gid) {
			auto begin = b_begin[gid];
			auto end = b_begin[gid + 1];

			/* get operations for each nodes of each graph */
			for (unsigned int nid = begin; nid < end; ++nid)
				operations[nid] = rule.operation(*this, begin, end, nid);
		}

		/* !!!!!!!!!!!!!!!!
		step (2) 
		 !!!!!!!!!!!!!!!! */

		#pragma omp parallel for
		for (unsigned int gid = 0; gid < numb_graphs; ++gid)
			/* get the number of child for each graph */
			num_childs[gid] = rule.numb_childs(*this, gid);

		/* !!!!!!!!!!!!!!!!
		step (3) 
		 !!!!!!!!!!!!!!!! */

		size_t total_num_graphs = 0;

		/* compute the total number of child in parallel */
		#pragma omp parallel for reduction(+:total_num_graphs)
		for (auto &num_graph : num_childs)
			total_num_graphs += num_graph;

		/* resize variables with the right number of elements */
		new_gid.resize(total_num_graphs);
		parent_gid.resize(total_num_graphs);
		parent_sub_id.resize(total_num_graphs);
		new_real.resize(total_num_graphs);
		new_imag.resize(total_num_graphs);

		/* fill gid with [0, 1, 2... total_num_graphs - 1] */
		std::iota(new_gid.begin(), new_gid.end(), 0);

		unsigned int i = 0;
		for (unsigned int gid = 0; gid < numb_graphs; ++gid) {
			unsigned int const num_child = num_childs[gid];

			/* assign parent ids and child ids for each child */
			for (unsigned int child_id = 0; child_id < num_child; ++child_id) {
				parent_gid[i] = gid;
				parent_sub_id[i] = child_id;
				++i;
			}
		}

		/* !!!!!!!!!!!!!!!!
		step (4) 
		 !!!!!!!!!!!!!!!! */

		#pragma omp parallel for
		for (unsigned int gid = 0; gid < total_num_graphs; ++gid) {
			auto [hash_, real_, imag_, size_b_, size_c_] = rule.child_properties(*this, parent_gid[gid], parent_sub_id[gid]);

			/* assign propreties for each child */
			new_hash[i] = hash_;
			new_real[i] = real_;
			new_imag[i] = imag_;
			new_size_b[i] = size_b_;
			new_size_c[i] = size_c_;
		}

		/* !!!!!!!!!!!!!!!!
		step (5) 
		 !!!!!!!!!!!!!!!! */

		/* sort graphs hash to compute interference
		!! TODO: implement it in parallel (https://cw.fel.cvut.cz/old/_media/courses/b4m35pag/lab6_slides_advanced_openmp.pdf) !! */
		std::sort(new_gid.begin(), new_gid.end(), [&](unsigned int const &gid1, unsigned int const &gid2) {
			return new_hash[gid1] > new_hash[gid2];
		});

		/* compute is_first_index */
		std::vector<bool> is_first_index(total_num_graphs);
		is_first_index[0] = true;

		#pragma omp parallel for
		for (unsigned int gid = 1; gid < total_num_graphs; ++gid)
			is_first_index[i] = new_hash[gid] != new_hash[gid - 1];

		/* !! will be done in parallel by splitting into work groups by hand !! */
		for (unsigned int gid = 1; gid < total_num_graphs; ++gid) {
			unsigned int gid0 = gid;

			/* sum magnitude of equal graphs */
			++gid;
			for (; gid < total_num_graphs && !is_first_index[gid]; ++gid) {
				new_real[gid0] += new_real[gid]; new_real[gid] = 0;
				new_imag[gid0] += new_imag[gid]; new_imag[gid] = 0;
			}
		}

		/* get all graphs with a non zero probability */
		auto partitioned_it = std::partition(new_gid.begin(), new_gid.end(), [&](unsigned int const &gid) {
			return new_real[gid] != 0 || new_imag[gid] != 0; 
		});
		total_num_graphs = std::distance(new_gid.begin(), partitioned_it);

		/* !!!!!!!!!!!!!!!!
		step (6) 
		 !!!!!!!!!!!!!!!! */

		if (n_graphs > 0 && total_num_graphs > n_graphs) {

			/* sort graphs according to probability */
			std::ranges::nth_element(new_gid.begin(), new_gid.begin() + n_graphs, new_gid.begin() + total_num_graphs,
			[&](unsigned int const &gid1, unsigned int const &gid2) {
				auto r1 = new_real[gid1];
				auto i1 = new_imag[gid1];

				auto r2 = new_real[gid2];
				auto i2 = new_imag[gid2];

				return r1*r1 + i1*i1 > r2*r2 + i2*i2;
			});

			total_num_graphs = n_graphs;
		}

		/* !!!!!!!!!!!!!!!!
		step (7) 
		 !!!!!!!!!!!!!!!! */

		state_t new_state;

		/* resize new step variables */
		new_state.real.resize(total_num_graphs);
		new_state.imag.resize(total_num_graphs);
		new_state.num_childs.resize(total_num_graphs);
		new_state.b_begin.resize(total_num_graphs + 1);
		new_state.c_begin.resize(total_num_graphs + 1);

		/* compute size (b) and (c) ... */
		size_t size_b = 0;
		size_t size_c = 0;
		for (unsigned int gid = 0; gid < total_num_graphs; ++gid) {
			/* ...and assign "b_begin" and "c_begin" */
			new_state.b_begin[gid] = size_b;
			new_state.c_begin[gid] = size_c;

			auto id = new_gid[gid];

			new_state.real[gid] = new_real[id];
			new_state.imag[gid] = new_imag[id];

			size_b += new_size_b[id];
			size_c += new_size_c[id];
		}

		new_state.b_begin[total_num_graphs] = size_b;
		new_state.c_begin[total_num_graphs] = size_c;

		/* resize new step variables */
		new_state.left.resize(size_b);
		new_state.right.resize(size_b);
		new_state.nid.resize(size_b);
		new_state.operations.resize(size_b);
		new_state.num_childs.resize(size_b);
		new_state.left_idx__or_element__and_has_most_left_zero_.resize(size_c);
		new_state.right_idx__or_type_.resize(size_c);
		new_state.node_hash.resize(size_c);		

		/* !!!!!!!!!!!!!!!!
		step (8) 
		 !!!!!!!!!!!!!!!! */

		#pragma omp parallel for
		for (unsigned int gid = 0; gid < total_num_graphs; ++gid) {
			auto id = new_gid[gid];

			/* populate graphs */
			rule.populate_new_graph(*this, new_state, gid, parent_gid[id], parent_sub_id[id]);
		}

		return new_state;
	}
};